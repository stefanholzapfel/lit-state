{"version":3,"file":"html.js","sourceRoot":"","sources":["../src/lib/html.ts"],"names":[],"mappings":"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","sourcesContent":["import { TemplatePart, createMarker } from \"./template\";\n\nconst markerRegex = /{{(.*?)}}/;\n\nexport class HTMLTemplate {\n  element: HTMLTemplateElement;\n  parts: TemplatePart[] = [];\n\n  constructor(element: HTMLTemplateElement) {\n    this.element = element;\n    let index = -1;\n    let partIndex = 0;\n    const nodesToRemove: Node[] = [];\n\n    const walker = document.createTreeWalker(\n      element.content, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n\n    while (walker.nextNode()) {\n      index++;\n      const node = walker.currentNode as Element | Comment | Text;\n      if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n        if ((node as Element).hasAttributes()) {\n          const attributes = Array.from((node as Element).attributes);\n          for (let i = 0; i < attributes.length; i++) {\n            const attr = attributes[i];\n            const result = attr.value.split(markerRegex);\n            console.log('result', result);\n            const attributeStrings = result.filter((_, i) => i % 2 === 0);\n            // const exprStrings = result.filter((_, i) => i % 2 === 1);\n            console.log('attributeStrings', attributeStrings);\n            if (attributeStrings.length > 0) {\n              this.parts.push({\n                type: 'attribute',\n                index,\n                name,\n                strings: attributeStrings,\n              });\n              (node as Element).removeAttribute(attr.name);\n              partIndex += attributeStrings.length - 1;\n            }\n          }\n        }\n      } else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n        const data = (node as Text).data!;\n        const parent = node.parentNode!;\n        const result = data.split(markerRegex);\n        const strings = result.filter((_, i) => i % 2 === 0);\n        if (strings.length > 0) {\n          const lastIndex = strings.length - 1;\n          // Generate a new text node for each literal section\n          // These nodes are also used as the markers for node parts\n          for (let i = 0; i < lastIndex; i++) {\n            parent.insertBefore(\n                (strings[i] === '') ? createMarker() :\n                                      document.createTextNode(strings[i]),\n                node);\n            this.parts.push({type: 'node', index: ++index});\n          }\n          // If there's no text, we must insert a comment to mark our place.\n          // Else, we can trust it will stick around after cloning.\n          if (strings[lastIndex] === '') {\n            parent.insertBefore(createMarker(), node);\n            nodesToRemove.push(node);\n          } else {\n            (node as Text).data = strings[lastIndex];\n          }\n          // We have a part for each match found\n          partIndex += lastIndex;\n        }\n      }\n    }\n  }\n}\n"]}